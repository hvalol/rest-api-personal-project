name: Node.js CI/CD to VMs

on:
  push:
    branches:
      - main
      - staging
      - develop
  pull_request:
    branches:
      - main
      - staging
      - develop

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }} # ghcr.io/username/repository-name
  DB_CONTAINER_NAME_PREFIX: "pgdb-" # e.g., pgdb-dev, pgdb-staging
  APP_CONTAINER_NAME_PREFIX: "app-"  # e.g., app-dev, app-staging

jobs:
  test: # Renamed from test-and-lint for clarity
    name: Test & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      - run: npm ci
      - run: npm run lint # Assuming you have a lint script
      - run: npm test   # Assuming you have a test script

  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/develop')
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image_tag.outputs.tag }} # Output the tag for deploy jobs

    steps:
      - uses: actions/checkout@v4
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Determine Docker image tag
        id: image_tag
        run: |
          BRANCH_NAME=$(echo "${{ github.ref_name }}" | tr '/' '-')
          # Use branch name for dev/staging, 'latest' and version for main
          if [[ "${{ github.ref_name }}" == "main" ]]; then
            TAG="latest"
            # Potentially add version tagging here if you use git tags
          else
            TAG="${BRANCH_NAME}"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.image_tag.outputs.tag }}

  deploy:
    name: Deploy to VM
    runs-on: ubuntu-latest
    needs: build-and-push
    # This job will run for pushes to develop, staging, and main
    # We'll use conditions within steps or separate jobs if logic differs significantly
    # For simplicity, one deploy job using environment-specific secrets
    strategy:
      matrix:
        environment_name: ['development', 'staging', 'production']
      fail-fast: false # Allow other environments to deploy if one fails

    # Conditions to run for specific branches
    if: |
      (github.ref == 'refs/heads/develop' && matrix.environment_name == 'development') ||
      (github.ref == 'refs/heads/staging' && matrix.environment_name == 'staging') ||
      (github.ref == 'refs/heads/main' && matrix.environment_name == 'production')

    environment: ${{ matrix.environment_name }} # Use GitHub Environments for secrets

    steps:
      - name: Set up environment variables for deployment
        id: env_vars
        run: |
          if [[ "${{ matrix.environment_name }}" == "development" ]]; then
            echo "VM_HOST=${{ secrets.DEV_VM_HOST }}" >> $GITHUB_OUTPUT
            echo "VM_USERNAME=${{ secrets.DEV_VM_USERNAME }}" >> $GITHUB_OUTPUT
            echo "VM_SSH_KEY=${{ secrets.DEV_VM_SSH_PRIVATE_KEY }}" >> $GITHUB_OUTPUT
            echo "DB_PASSWORD=${{ secrets.DEV_DB_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "DB_USER=postgres" >> $GITHUB_OUTPUT # Default PostgreSQL user
            echo "DB_NAME=dev_db" >> $GITHUB_OUTPUT
            echo "APP_PORT=3000" >> $GITHUB_OUTPUT # Port app listens on inside container
            echo "EXPOSED_APP_PORT=3000" >> $GITHUB_OUTPUT # Port exposed on VM for dev
            echo "ENV_FILE_CONTENT=$(echo -e "NODE_ENV=development\nDATABASE_URL=postgresql://postgres:${{ secrets.DEV_DB_PASSWORD }}@${{ env.DB_CONTAINER_NAME_PREFIX }}${{ matrix.environment_name }}:5432/dev_db\nJWT_SECRET=${{ secrets.JWT_SECRET_DEV }}\nPUBLIC_API_KEY=${{ secrets.PUBLIC_API_KEY_DEV }}")" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.environment_name }}" == "staging" ]]; then
            echo "VM_HOST=${{ secrets.STAGING_VM_HOST }}" >> $GITHUB_OUTPUT
            echo "VM_USERNAME=${{ secrets.STAGING_VM_USERNAME }}" >> $GITHUB_OUTPUT
            echo "VM_SSH_KEY=${{ secrets.STAGING_VM_SSH_PRIVATE_KEY }}" >> $GITHUB_OUTPUT
            echo "DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "DB_USER=postgres" >> $GITHUB_OUTPUT
            echo "DB_NAME=staging_db" >> $GITHUB_OUTPUT
            echo "APP_PORT=3000" >> $GITHUB_OUTPUT
            echo "EXPOSED_APP_PORT=3001" >> $GITHUB_OUTPUT # Example: staging on different port
            echo "ENV_FILE_CONTENT=$(echo -e "NODE_ENV=staging\nDATABASE_URL=postgresql://postgres:${{ secrets.STAGING_DB_PASSWORD }}@${{ env.DB_CONTAINER_NAME_PREFIX }}${{ matrix.environment_name }}:5432/staging_db\nJWT_SECRET=${{ secrets.JWT_SECRET_STAGING }}\nPUBLIC_API_KEY=${{ secrets.PUBLIC_API_KEY_STAGING }}")" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_OUTPUT
          elif [[ "${{ matrix.environment_name }}" == "production" ]]; then
            echo "VM_HOST=${{ secrets.PRODUCTION_VM_HOST }}" >> $GITHUB_OUTPUT
            echo "VM_USERNAME=${{ secrets.PRODUCTION_VM_USERNAME }}" >> $GITHUB_OUTPUT
            echo "VM_SSH_KEY=${{ secrets.PRODUCTION_VM_SSH_PRIVATE_KEY }}" >> $GITHUB_OUTPUT
            echo "DB_PASSWORD=${{ secrets.PRODUCTION_DB_PASSWORD }}" >> $GITHUB_OUTPUT
            echo "DB_USER=postgres" >> $GITHUB_OUTPUT
            echo "DB_NAME=production_db" >> $GITHUB_OUTPUT
            echo "APP_PORT=3000" >> $GITHUB_OUTPUT
            echo "EXPOSED_APP_PORT=3002" >> $GITHUB_OUTPUT # Example: prod on different port (or 80/443 via proxy)
            echo "ENV_FILE_CONTENT=$(echo -e "NODE_ENV=production\nDATABASE_URL=postgresql://postgres:${{ secrets.PRODUCTION_DB_PASSWORD }}@${{ env.DB_CONTAINER_NAME_PREFIX }}${{ matrix.environment_name }}:5432/production_db\nJWT_SECRET=${{ secrets.JWT_SECRET_PRODUCTION }}\nPUBLIC_API_KEY=${{ secrets.PUBLIC_API_KEY_PRODUCTION }}")" >> $GITHUB_OUTPUT
            echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ${{ matrix.environment_name }} VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ steps.env_vars.outputs.VM_HOST }}
          username: ${{ steps.env_vars.outputs.VM_USERNAME }}
          key: ${{ steps.env_vars.outputs.VM_SSH_KEY }}
          port: 22 # Default SSH port
          script: |
            set -e # Exit immediately if a command exits with a non-zero status.
            echo "Deploying to ${{ matrix.environment_name }} VM..."
            APP_NAME="${{ env.APP_CONTAINER_NAME_PREFIX }}${{ matrix.environment_name }}"
            DB_NAME_CONTAINER="${{ env.DB_CONTAINER_NAME_PREFIX }}${{ matrix.environment_name }}"
            DB_VOLUME_NAME="${DB_NAME_CONTAINER}}-data"
            DB_USER_VALUE="${{ steps.env_vars.outputs.DB_USER }}"
            DB_PASSWORD_VALUE="${{ steps.env_vars.outputs.DB_PASSWORD }}"
            DB_NAME_VALUE="${{ steps.env_vars.outputs.DB_NAME }}"
            APP_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.env_vars.outputs.IMAGE_TAG }}"
            APP_PORT_VALUE="${{ steps.env_vars.outputs.APP_PORT }}"
            EXPOSED_APP_PORT_VALUE="${{ steps.env_vars.outputs.EXPOSED_APP_PORT }}"
            ENV_FILE_PATH="/opt/${APP_NAME}/.env" # Path on VM for .env file

            # Create app directory if it doesn't exist
            sudo mkdir -p /opt/${APP_NAME}
            sudo chown ${{ steps.env_vars.outputs.VM_USERNAME }}:${{ steps.env_vars.outputs.VM_USERNAME }} /opt/${APP_NAME}
            echo "Creating .env file on VM at ${ENV_FILE_PATH}"
            echo "${{ steps.env_vars.outputs.ENV_FILE_CONTENT }}" > ${ENV_FILE_PATH}
            echo ".env file created."

            # Ensure Docker network exists (create if not)
            docker network inspect app-network >/dev/null 2>&1 || docker network create app-network
            echo "Docker network 'app-network' ensured."

            # Start PostgreSQL Database Container (if not already running)
            if [ ! "$(docker ps -q -f name=^/${DB_NAME_CONTAINER}$)" ]; then
              if [ "$(docker ps -aq -f status=exited -f name=^/${DB_NAME_CONTAINER}$)" ]; then
                echo "Removing exited DB container ${DB_NAME_CONTAINER}..."
                docker rm ${DB_NAME_CONTAINER}
              fi
              echo "Starting PostgreSQL container ${DB_NAME_CONTAINER}..."
              docker run -d \
                --name ${DB_NAME_CONTAINER} \
                --network app-network \
                -e POSTGRES_USER=${DB_USER_VALUE} \
                -e POSTGRES_PASSWORD=${DB_PASSWORD_VALUE} \
                -e POSTGRES_DB=${DB_NAME_VALUE} \
                -v ${DB_VOLUME_NAME}:/var/lib/postgresql/data \
                --restart unless-stopped \
                postgres:15-alpine
              echo "PostgreSQL container started. Waiting for DB to be ready..."
              sleep 15 # Give PostgreSQL time to initialize
            else
              echo "PostgreSQL container ${DB_NAME_CONTAINER} is already running."
            fi

            # Pull the latest application image
            echo "Pulling application image ${APP_IMAGE}..."
            docker pull ${APP_IMAGE}

            # Stop and remove existing application container (if any)
            echo "Stopping and removing old application container ${APP_NAME}..."
            docker stop ${APP_NAME} || true
            docker rm ${APP_NAME} || true

            # Run the new application container
            echo "Starting new application container ${APP_NAME}..."
            docker run -d \
              --name ${APP_NAME} \
              --network app-network \
              -p ${EXPOSED_APP_PORT_VALUE}:${APP_PORT_VALUE} \
              --env-file ${ENV_FILE_PATH} \
              --restart unless-stopped \
              ${APP_IMAGE}
            echo "Application container started."

            # Wait for app to be ready and then run migrations
            echo "Waiting for application to initialize..."
            sleep 10 # Adjust as needed
            echo "Running database migrations..."
            docker exec ${APP_NAME} npm run db:migrate:prod # Assumes sequelize-cli is in your app's dependencies
            echo "Database migrations complete."

            # Optionally run seeders (be careful with this in prod)
            if [[ "${{ matrix.environment_name }}" == "development" || "${{ matrix.environment_name }}" == "staging" ]]; then
              echo "Running database seeders for ${{ matrix.environment_name }}..."
              docker exec ${APP_NAME} npm run db:seed:prod # Assumes script exists
              echo "Database seeders complete."
            fi

            echo "Deployment to ${{ matrix.environment_name }} VM finished."
